# 컴네_01분반_in-class-task

> 컴퓨터네트워크 01분반 in-class-task 답안
> 
> 
> **22000080 김민채**
> 
> **21700057 권혁찬**
> 
1. **TCP를 이용한 통신에서 message boundary를 구분한 통신**
- **결과화면**

> [Client]
> 
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image3.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image3.png)
> 
> **[Server]**
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image3.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image3.png)
> 
- **메세지를 구별하기 위해 사용한 방법**

> 메세지는 두줄 이상이기 때문에, 3개의 메세지 간의 끝나는 포인트를 알 수 있어야한다. 따라서 ‘\n’이 아닌 ‘#’라는 문자를 사용하여 마지막줄에 해당 문자가 존재한다면 메세지가 끝나 다음 동작을 실행할 수 있게 했다.
> 
> 
> 반복문을 만들어 ‘#’ 문자가 올 때까지 지속적으로 메세지를 읽을 수 있게 했으며, 보내질 메세지(send_message)에 읽어온 메세지를 이어붙이는 방법을 사용했다. 각각의 메세지 읽기가 끝나면(‘#’문자가 들어오면), 해당 메세지의 길이를 값을 int type으로 저장하여 write()를 사용하여 server로 먼저 보내줬다. 서버에서는 해당 값을 받아 다음에 올 메세지의 총 길이를 알 수 있게 된다. 이어서 client에서 메세지를 보내게 되면, server에서는 길이에 맞는 buffer만을 불러와 각각의 메세지로 구별할 수 있었다.
> 
1. **UDP 기반 socket program에서 특징 분석**
2. **여럿의 message가 이미 도착을 한 상태에서 큰 버퍼를 이용하여 수신 데이터를 읽을 때, 어떻게 되는 가를 분석**
- **결과화면**

> [server]
> 
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image5.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image5.png)
> 
> **[client]**
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image4.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image4.png)
> 
- **분석내용**

> 수신하는 측(server)에서 데이터를 받을 준비를 하고 충분한 시간동안 sleep을 하여 여럿의 message가 이미 도착을 한 상태에서 큰 버퍼(100byte)를 이용하여 수신 데이터를 읽을 때, 모든 메세지의 크기가 버퍼보다 작으므로 정상적으로 메세지가 전송된다.
> 
1. **보내진 메세지보다 작은 버퍼 크기로 메세지를 읽을 때, 어떻게 되는가를 분석**
- **결과 화면**

> [server]
> 
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image2.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image2.png)
> 
> **[client]**
> 
> ![%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image1.png](%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%82%E1%85%A6_01%E1%84%87%E1%85%AE%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AB_in-class-task%20eee907c74ac543c98cba03c85a5edbcf/image1.png)
> 
- **분석 내용**

> 수신하는 측(client)에서 데이터를 받을 준비를 하고 충분한 시간동안 sleep을 하여 여럿의 message가 이미 도착을 한 상태에서 보내진 메세지보다 작은 버퍼 크기(10byte)로 메세지를 읽을 때, 어떤 메세지의 크기는 버퍼보다 작으므로 정상적으로 보내지지 않고 그 메세지는 버퍼를 넘어가는 char은 삭제된다. 이때 그렇게 잘려서 삭제된 char은 다음 메세지나 buffer로 들어가지 않고, 그냥 삭제된다.
> 
> 
> 왜냐하면 udp/ip는 송수신이 한번에 완료되기 때문에 송신 쪽에서 한번의 송신으로 보낸 데이터는 수신 쪽에서도 한번의 수신으로 모두 받을 수 있어야 한다. 이렇게 한번의 송신으로 데이터를 모두 보낼 수 있는 단위를 ‘데이터 경계'라는 것으로 판별한다. 이때, 만약 첫 번째 송신에서 loss된 데이터를 두 번째 송신에서 받는다면 이 데이터 경계가 모호해진다.
> 
> 따라서 udp를 사용할 때, loss되지 않아야 하는 중요한 데이터라면 그 데이터들의 최대 길이보다 buffer가 크거나, 혹은 udp의 패킷마다 번호를 붙여서 tcp형식처럼 만들거나, 그냥 tcp를 사용해야 한다.
>